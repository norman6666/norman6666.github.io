<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://norman6666.github.io</id>
    <title>Norman的Little_blog</title>
    <updated>2023-02-18T00:57:41.998Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://norman6666.github.io"/>
    <link rel="self" href="https://norman6666.github.io/atom.xml"/>
    <subtitle>生活没有一劳永逸，想要不被抛弃，必须自己争气。</subtitle>
    <logo>https://norman6666.github.io/images/avatar.png</logo>
    <icon>https://norman6666.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, Norman的Little_blog</rights>
    <entry>
        <title type="html"><![CDATA[主体段攻略01——巧用"五三"模式]]></title>
        <id>https://norman6666.github.io/post/tui/</id>
        <link href="https://norman6666.github.io/post/tui/">
        </link>
        <updated>2023-02-01T09:16:37.000Z</updated>
        <content type="html"><![CDATA[<p>主体段攻略01——巧用&quot;五三&quot;模式<br>
模块一 巧用&quot;五三&quot;模式写主体段<br>
一个标准的议论段, 其实也是一篇具体而微的议论文,也要&quot;五脏俱全&quot;,要有观点句、材料句、分析句。 规范的议论文中要有2至3个这样的主体段落, 意义上相对独立完整,篇幅上长短适中,一般为200至300字。 主体段落的写作思路是先提出分论点,然后列举论据( 包括道理论据 ),最后紧扣观点,对论据进行分析议论。<br>
1.完善要素<br>
一个标准的议论段一定要包含论点、论据和分析等要素;一般包含五种功能不同的句子:<br>
2.巧用模式<br>
写作模式是写作思维的外化, 也是成功经验的总结,包含着诸多智慧。 在学生初学写作议论文的时候,套用此模式可以快速提高写作水平。<br>
主体段落的写作模式可以概括为&quot;五句三层&quot;,简称&quot;五三&quot;模式。 &quot;五句&quot;模式,即观点句+阐释句+材料句+分析句+结论。&quot;三层&quot;模式,即一个典型的议论段一般三个层次:提出观点( 观点句)一一分析问题( 阐释句、材料句、分析句)一一得出结论(结论句)。<br>
当然,在具体行文时,其构成方式往往干变万化,但不管怎样,一定要有的是观点、事例、分析。这就是所谓的巧用模式。<br>
一、使用举例论证的方法，一个议论文主体段，大体可由3-5句话构成：<br>
1观点句+2阐释句+3例子句+4分析句+5结论句标示红色的1.3.4三个句子是底线要求，就是必须有这三句话，其他两句可以没有。<br>
文段举例说明<br>
1.例：贫困也是一笔财富。“自古才子出寒门”。司马光出身贫寒；范仲淹两岁丧父，随母改嫁，幼时连稠一点的粥都难以喝到；明代龙图大学士宋濂家中一贫如洗。荷兰画家梵高也曾穷困潦倒，一文不名，生活上常靠着弟弟接济；苏联伟大作家高尔基曾经是个流浪儿；居里夫人刚满十岁就外出打工……可见贫困也是一笔财富。<br>
优点:观点明确，论据丰富。<br>
缺点:“观点＋论据”格局。<br>
弊端:论点和论据之间互相脱离，两者之间缺乏必要的联系的桥梁，论点还是论点，论据还是论据；论据失去了其应有的作用，论点孤立无援，也就失去了立足的依据。这种“不讲道理”的议论文，论点无论怎样正确，也不足以服人；论据无论怎样充足，也不过是一堆零碎的材料。<br>
2.修改建议：补充内容，规范成段<br>
贫困也是一笔财富。（观点句）自古“寒门出贵子，白屋出公卿”，贫困让人学会努力、学会思考、学会成长。（阐释句）司马光出身贫寒；范仲淹两岁丧父，随母改嫁，幼时连稠一点的粥都难以喝到；明代龙图大学士宋濂家中一贫如洗。荷兰画家梵高也曾穷困潦倒，一文不名，生活上常靠着弟弟接济；苏联伟大作家高尔基曾经是个流浪儿；居里夫人刚满十岁就外出打工（材料句）他们因为贫穷，才更知道珍惜，知道只有靠自己的努力才能摆脱。因为贫穷，才会在黑暗中长途跋涉，在逆境中执着前行。（分析句）可见贫困也是一笔财富。（结论句）<br>
“五三模式”段落构成<br>
主体段落的写作模式可以概括为&quot;五句三层&quot;,简称&quot;五三&quot;模式。<br>
&quot;三层&quot;模式,即一个典型的议论段一般三个层次:提出观点( 观点句)一一分析问题( 阐释句、材料句、分析句)一一得出结论(结论句)。<br>
不管怎样,一定要有的是观点、事例、分析。<br>
( 1 )观点句:开头句( 阐明观点、扣中心论点、扣住关键词)。写法:阐述观点,表达判断的一句话。<br>
( 2 )阐释句:对观点阐释(强调、引用名言与个人说理相结合)。写法:①解释:这句话告诉我们……;②强调:只有……才能……(如果……就……);③延伸:由此我联想到……。<br>
( 3 )材料句:列举事例(概述或综述)。写法:①概述:转述重点内容;②概述+重点言行;③综述。举事实论证，叙述讲究简明扼要，选材角度准确。要求只写人物、事件、结果；不要细节描写，删除无关情节，紧扣观点句，最好点出关键词。事例要简洁、多样化，建议写三五个事例，涉及古今中外，不同领域、正反。<br>
( 4 )分析句:分析道理。一方面可分析原因、性质、挖掘意义,也可正例反设或反例正设等。写法:①原因分析;②假设分析;③意义分析。另一方面可反面假设。写法:①试想:假如/倘若/若……;②反问:如果/假如没有……吗?+扣题。    多用问句、感叹句，增强语言力度。<br>
( 5 )结论句:总结观点，联系实际适当延伸，回应段首观点句。写法:①可见;②总而言之;③因此;④所以。<br>
“五三模式”段落示例<br>
褪出急躁，心境将会更加澄明。（分论点句）“不戚戚于贫贱，不汲汲于富贵”，去除急躁与妄动，方能洞察人生之哲理。（阐释句）陶渊明，古往今来遗世独立之典范，有着“或命巾车，或棹孤舟”之闲情，更具“登东皋以舒啸，临清流而赋诗”的逸致。（事例句）如果不是面对督邮的从容与淡定，又哪有如此之高情远致？（分析句）可见，摒弃世俗之浮躁，停下匆匆过往之脚步，原来我们的身边也有无限美丽的风景，我们的心境也会因此而更加澄明。（小结句）</p>
<p>模块二 巧用&quot;五三&quot;模式升格段落<br>
二、阅读下面两个段落，分析它们分别有什么不足，然后按照“五三模式”进行改造升格。<br>
（一）《缩小痛苦   正视痛苦》<br>
升格前：缩小痛苦，百折不挠，人生才可能璀璨。（观点句）身怀用世之心的杜甫，命途多舛，颠沛一生，但他始终以仁圣襟怀观人视物，将挫败与坎坷当做人生的历练，即使在忧郁的深渊中仍不懈追求，终于以字字句句饱含生命力的诗作，成为唐诗这一宏丽壮伟的琼宇中巨实的一柱栋梁，享有“诗圣”的称誉。（例子句）可见缩小痛苦对一个处于坎坷中的人来说很是重要。（结论句）【点评：很显然，这一段缺乏必要的分析句。没有分析句，也就无法把例子与观点句勾连起来。升格时，就要补上分析句。推荐假设分析法和原因分析法。】</p>
<p>升格后：缩小痛苦，百折不挠，人生才可能璀璨。（观点句）身怀用世之心的杜甫，命途多舛，颠沛一生，但他始终以仁圣襟怀观人视物，将挫败与坎坷当做人生的历练，即使在忧郁的深渊中仍不懈追求，终于以字字句句饱含生命力的诗作，成为唐诗这一宏丽壮伟的琼宇中巨实的一柱栋梁，享有“诗圣”的称誉。（材料句）假如杜甫在那个时局纷乱的年代不堪命运的捉弄而随波逐流，假如他无法正视如黄叶般飘摇孤寂的生命而丧失人生的意志，假如他无法承担失意、离索的痛楚而放弃了“治国平天下”的理想，那么，他怎能吟出不朽的“诗史”之作而震古烁今？正因为那份对痛苦的淡然，才能让杜甫在西南一隅活出了“月白清风一草堂”的旷达，从而成就了他的璀璨人生!（分析句，论证充分，显示思想深度。）可见缩小痛苦对一个处于坎坷中的人来说很是重要。（结论句）</p>
<p>（二）《竞争出精彩》<br>
升格前：在纷繁复杂的社会发展形势下，没有天敌和竞争的世界让沙丁鱼‘高枕无忧’，同时也助长了它的懈怠，使它们更快的走向死亡。在日常生活中亦是如此。我们工作没有丝毫竞争，就会安于现状不思进取。就会没有危机感，每天得过且过。（语言表达过于平淡、内容单薄，说理缺乏力度。）</p>
<p>升格后： 在纷繁复杂的社会发展形势下，竞争不仅是社会趋势，也是社会进步的必需。（观点句）与其心生恐惧而逃避，不如乐观的主动地面对，在竞争中活出自己的一份精彩。（阐释句，承上启下）没有天敌和竞争的世界虽然让沙丁鱼‘高枕无忧’，但是这也消磨了它们的斗志，使它们更快的走向死亡。在日常生活中亦是如此。如果工作没有丝毫竞争，我们也会丧失向上的意志，可是当有人与我们一同竞争时，为了不被别人超越，所以我们竭尽所能，抢先一步捍卫自己的东西，不断地爆发新的潜力。（例子句+分析句，夹叙夹议）由此可见，竞争的意识，使我们不会在这个快速发展的社会被淘汰掉。”（结论句）（逻辑思维清晰，观点鲜明，说理有层次。）</p>
<p>总结：张志公先生曾言：“在语言表达中，段落是至关重要的。几乎可以断言，能够写好一段，就一定能写好一篇。”主体段（核心论证段落）的写法复杂多变，但如果写好了，一篇作文就成功一大，主体段落具备了“五三”模式，就有了议论文的雏形。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[终于可以啦？]]></title>
        <id>https://norman6666.github.io/post/zhong-yu-ke-yi-la/</id>
        <link href="https://norman6666.github.io/post/zhong-yu-ke-yi-la/">
        </link>
        <updated>2023-01-11T14:14:21.000Z</updated>
        <content type="html"><![CDATA[<p>呜呜呜呜<br>
wtf?</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [517coding 3910/4148] 最大子矩阵和]]></title>
        <id>https://norman6666.github.io/post/ti-jie-517coding-39104148-zui-da-zi-ju-zhen-he/</id>
        <link href="https://norman6666.github.io/post/ti-jie-517coding-39104148-zui-da-zi-ju-zhen-he/">
        </link>
        <updated>2021-04-11T07:16:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题解-517coding-39104148-最大子矩阵和">题解 [517coding 3910/4148] 最大子矩阵和</h2>
<h3 id="方法动态规划">方法：动态规划</h3>
<p>这题我们可以用动态规划解决。</p>
<p>我们枚举每列的两个下标 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>，表示原二维矩阵的最大子矩阵所在的列在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>。</p>
<ul>
<li>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i = j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>，则最大子矩阵和为第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 行的最大字段和。</li>
<li>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mtext> </mtext><mo>!</mo><mo>=</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i\ != j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace"> </span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> ，已知最大子矩阵的行的范围，求列的范围；我们把从第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 行到第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 行的所有行相加，得到一个只有一行的一维数组，则该一维数组的最大子段和就是最大子矩阵和。</li>
</ul>
<p>而求一维数组的最大字段和，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>+</mo><mi>b</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo separator="true">,</mo><mi>b</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">dp[i] = max(dp[i - 1] + b[i],b[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span>。</p>
<p>具体见代码。</p>
<h2 id="code">Code:</h2>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
//考虑unsigned long long
typedef long long ll;
inline int read(){
	int z=0,x=1;char c=getchar();
	while(c&gt;'9'||c&lt;'0'){if(c=='-') x=-x; c=getchar();}
	while(c&gt;='0'&amp;&amp;c&lt;='9') z=z*10+c-'0',c=getchar();
	return z*x;
}
inline void write(ll x){
    if(x&lt;0) putchar('-'),x=-x;
    if(x&gt;9) write(x/10);
    putchar(x%10+'0');
}
const int N = 210;
int a[N][N];
int b[N],dp[N];

//把矩阵 a 的第 i 行到第 j 行进行合并，并求出连续最大和
int to_get(int i,int j,int n) {
    //初始化
	memset(b,0,sizeof(b));
	memset(dp,0,sizeof(dp));
    //合并至 b 数组
	for (int k = i;k &lt;= j;k++) {
		for (int l = 1;l &lt;= n;l++) {
			b[l] += a[k][l];
		}
	}
    //len 表示 列数
	int len = n;
    //初始化
	dp[1] = b[1];
	for (int k = 2;k &lt;= len;k++) {
		dp[k] = max(dp[k - 1] + b[k],b[k]);
	}
    //ans 取最大值
	int ans = dp[1];
	for (int k = 1;k &lt;= len;k++) {
		ans = max(ans,dp[k]);
	}
	return ans;
}

int main () {
	int n = read();
	for (int i = 1;i &lt;= n;i++) {
		for (int j = 1;j &lt;= n;j++) {
			a[i][j] = read();
		}
	}
	int mx = -0x3f3f3f3f;
	for (int i = 1;i &lt;= n;i++) {
		for (int j = i;j &lt;= n;j++) {
            //取最大值
			int op = to_get(i,j,n);
			mx = max(mx,op); 
		}
	}
	cout &lt;&lt; mx;
	return 0;
}
</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>h</mi><mi>e</mi><mtext> </mtext><mi>e</mi><mi>n</mi><mi>d</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">The\ end.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mspace"> </span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord">.</span></span></span></span></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [517coding 4105]最小的最长上升子序列]]></title>
        <id>https://norman6666.github.io/post/ti-jie-517coding-4105zui-xiao-de-zui-chang-shang-sheng-zi-xu-lie/</id>
        <link href="https://norman6666.github.io/post/ti-jie-517coding-4105zui-xiao-de-zui-chang-shang-sheng-zi-xu-lie/">
        </link>
        <updated>2021-04-11T07:16:31.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题解-517coding-4105最小的最长上升子序列">题解 [517coding 4105]最小的最长上升子序列</h2>
<h3 id="方法动态规划">方法：动态规划</h3>
<p>这题我们可以用动态规划解决。</p>
<p>每次二分查找 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span></span></span></span> 数组中第一个大于等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 的位置，然后更新 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>，这样保证 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 中的数一定是当前最小的。</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">op[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 表示以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">arr[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 结尾的最长上升子序列长度</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">cnt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span> 就表示最长上升子序列的长度</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>m</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">tmp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span></span></span></span> 表示就是说最长上升子序列的末尾是哪一个</li>
</ul>
<p>具体见代码。</p>
<h2 id="code">Code:</h2>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
//考虑unsigned long long
typedef long long ll;
inline int read(){
	int z=0,x=1;char c=getchar();
	while(c&gt;'9'||c&lt;'0'){if(c=='-') x=-x; c=getchar();}
	while(c&gt;='0'&amp;&amp;c&lt;='9') z=z*10+c-'0',c=getchar();
	return z*x;
}
inline void write(ll x){
    if(x&lt;0) putchar('-'),x=-x;
    if(x&gt;9) write(x/10);
    putchar(x%10+'0');
}
const int N = 100010;
int dp[N],op[N],a[N],ans[N];
int main () {
	int n = read();
	for (int i = 1;i &lt;= n;i++) {
		a[i] = read();
	}
    //特判不成立
	if (n == 0) {
		printf(&quot;orz&quot;);
		return 0;
	}
    //初始化cnt,tmp,op数组和dp数组
	int cnt = 1;
	int tmp = 1;
	op[1] = 1,dp[1] = a[1];
	for (int i = 2;i &lt;= n;i++) {
        //找到第一个大于a[i]的位置
		int b = lower_bound(dp+1,dp+1+cnt,a[i]) - dp;
        //更新dp,op
		dp[b] = a[i],op[i] = b;
        //特判新增一位
		if (b &gt;= cnt) {
            //tmp是为了减少一些复杂度，不加也行
			cnt = b,tmp = i;
		}
	}
	int b = cnt;
    //倒序选择最小值
	for (int i = tmp;i &gt;= 1;i--) {
		if (op[i] == cnt) {
			ans[cnt] = a[i];
			cnt--;
		}
	}
    //输出
	for (int i = 1;i &lt;= b;i++) {
		cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot;; 
	}
	return 0;
}

</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>h</mi><mi>e</mi><mtext> </mtext><mi>e</mi><mi>n</mi><mi>d</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">The\ end.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mspace"> </span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord">.</span></span></span></span></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [POJ 1631] Bridging signals(最长上升子序列)]]></title>
        <id>https://norman6666.github.io/post/ti-jie-poj-1631-bridging-signalszui-chang-shang-sheng-zi-xu-lie/</id>
        <link href="https://norman6666.github.io/post/ti-jie-poj-1631-bridging-signalszui-chang-shang-sheng-zi-xu-lie/">
        </link>
        <updated>2021-04-04T03:15:26.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题解-poj-1631-bridging-signals最长上升子序列">题解 [POJ 1631] Bridging signals(最长上升子序列)</h2>
<h3 id="方法动态规划">方法：动态规划</h3>
<p>这题我们可以用动态规划解决。</p>
<p>其实这题本质上就是最长上升子序列，也是很经典的一个问题了。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 做法：<code>dp[i] = max(dp[i],dp[j] + 1)</code>。</p>
<p>那么怎么用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 做呢？</p>
<p>我们维护一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">op</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span></span></span></span> 数组，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">op[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 表示当前最长上升子序列的第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个数的最小值是多少。</p>
<p>每当进入一个数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 时，如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 大于当前最长上升子序列的最大值，则新加一位。</p>
<p>否则用二分查找到第一位大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的数将其替换。</p>
<p>该部分处理代码：</p>
<pre><code class="language-cpp">	int cnt = 0;
	cnt++;
	op[cnt] = a[1];
	for (int i = 2;i &lt;= n;i++) {
		if (a[i] &gt; op[cnt]) {
            //新建一位
			cnt++;
			op[cnt] = a[i];
		} else {
            //二分
			int b = upper_bound(op+1,op+1+cnt,a[i]) - op;
			op[b] = a[i];
		}
	}
</code></pre>
<p>具体见代码。</p>
<h2 id="code">Code:</h2>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
//考虑unsigned long long
typedef long long ll;
inline int read(){
	int z=0,x=1;char c=getchar();
	while(c&gt;'9'||c&lt;'0'){if(c=='-') x=-x; c=getchar();}
	while(c&gt;='0'&amp;&amp;c&lt;='9') z=z*10+c-'0',c=getchar();
	return z*x;
}
inline void write(ll x){
    if(x&lt;0) putchar('-'),x=-x;
    if(x&gt;9) write(x/10);
    putchar(x%10+'0');
}
const int N = 40010;
int a[N];
int op[N];
int main () {
	int t = read();
	while (t--) {
		memset(a,0,sizeof(a));
		memset(op,0,sizeof(op));
		int n = read();
		for (int i = 1;i &lt;= n;i++) {
			a[i] = read();
		} 
		int cnt = 0;
		cnt++;
		op[cnt] = a[1];
		for (int i = 2;i &lt;= n;i++) {
            //新建一位
			if (a[i] &gt; op[cnt]) {
				cnt++;
				op[cnt] = a[i];
			} else {
                //二分
				int b = upper_bound(op+1,op+1+cnt,a[i]) - op;
				op[b] = a[i];
			}
		}
		cout &lt;&lt; cnt &lt;&lt; endl;
	}
	return 0;
}

</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>h</mi><mi>e</mi><mtext> </mtext><mi>e</mi><mi>n</mi><mi>d</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">The\ end.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mspace"> </span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord">.</span></span></span></span></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [UVA 1626 括号序列]/[POJ 1141] Brackets sequence]]></title>
        <id>https://norman6666.github.io/post/ti-jie-uva-1626-gua-hao-xu-lie-poj-1141-brackets-sequence/</id>
        <link href="https://norman6666.github.io/post/ti-jie-uva-1626-gua-hao-xu-lie-poj-1141-brackets-sequence/">
        </link>
        <updated>2021-04-03T14:51:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题解-uva-1626-括号序列poj-1141-brackets-sequence">题解 [UVA 1626 括号序列]/[POJ 1141] Brackets sequence</h2>
<h3 id="方法区间动态规划">方法：区间动态规划</h3>
<p>这题我们可以用区间动态规划解决。</p>
<p>首先吐槽一下这个输入方式，害人不浅啊。</p>
<p>进入正题：</p>
<p>我们用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 来表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 区间中变为合法括号序列添加的最少括号。</p>
<p>那么每一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i][i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 的值一开始必须为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，因为一个括号必须需要另一个括号才能匹配。</p>
<p>状态转移式子：</p>
<ul>
<li>如果此时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 匹配，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">dp[i][j] = min(dp[i][j],dp[i + 1][j - 1])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span>。</li>
<li>如不匹配则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mo>(</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>x</mi><mo>]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><msub><mo>)</mo><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">dp[i][j] = (dp[i][x] + dp[x + 1][j])_{min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo>≤</mo><mi>x</mi><mo>&lt;</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(i ≤ x &lt; j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>。</li>
</ul>
<p>同时我们用一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">go</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">o</span></span></span></span> 数组来记录 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i,j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 区间的最佳 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>x</mi><mo>]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i][x] + dp[x + 1][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 取最小值时。特别地，当他们匹配时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>o</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">go[i][j] = -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">o</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。</p>
<p>输出结果通过函数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">output</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span> 来实现：</p>
<pre><code class="language-c++">void out_put(int i,int j) {
	if (i &gt; j) {
		//非法的时候 
		return;
	} else if (i == j) {
		//当仅剩自己这一个括号时，直接输出一整对括号 
		if (a[i] == '[' || a[i] == ']') {
			printf(&quot;[]&quot;);
		} else {
			printf(&quot;()&quot;);
		}
		return;
	} else if (go[i][j] == -1) {
		//匹配时 
		printf(&quot;%c&quot;,a[i]);
		//往里缩 
		out_put(i + 1,j - 1);
		printf(&quot;%c&quot;,a[j]);
		return;
	} else {
		//分点处理 
		out_put(i,go[i][j]);
		out_put(go[i][j] + 1,j);
		return;
	}
}
</code></pre>
<p>具体见代码。</p>
<h2 id="code">Code:</h2>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
//考虑unsigned long long
typedef long long ll;
inline int read(){
	int z=0,x=1;char c=getchar();
	while(c&gt;'9'||c&lt;'0'){if(c=='-') x=-x; c=getchar();}
	while(c&gt;='0'&amp;&amp;c&lt;='9') z=z*10+c-'0',c=getchar();
	return z*x;
}
inline void write(ll x){
    if(x&lt;0) putchar('-'),x=-x;
    if(x&gt;9) write(x/10);
    putchar(x%10+'0');
}
const int N = 110;
int dp[N][N],go[N][N]; 
string a;

bool check(char a,char b) {
	if ((a == '[' &amp;&amp; b == ']') || (a == '(' &amp;&amp; b == ')')) {
		return true;
	}
	return false;
}

void out_put(int i,int j) {
	if (i &gt; j) {
		//非法的时候 
		return;
	} else if (i == j) {
		//当仅剩自己这一个括号时，直接输出一整对括号 
		if (a[i] == '[' || a[i] == ']') {
			printf(&quot;[]&quot;);
		} else {
			printf(&quot;()&quot;);
		}
		return;
	} else if (go[i][j] == -1) {
		//匹配时 
		printf(&quot;%c&quot;,a[i]);
		//往里缩 
		out_put(i + 1,j - 1);
		printf(&quot;%c&quot;,a[j]);
		return;
	} else {
		//分点处理 
		out_put(i,go[i][j]);
		out_put(go[i][j] + 1,j);
		return;
	}
}

int main () {
	int t;
	scanf(&quot;%d&quot;,&amp;t);
	getchar();
	while (t--) {
		//初始化 
		memset(dp,0,sizeof(dp));
		memset(go,0,sizeof(go));
		getline(cin, a);
		getline(cin, a);
		int n = a.size();
		if (n == 0) {
			puts(&quot;\n&quot;);
			continue;
		}
		//初始化 dp 
		for (int i = 0;i &lt; n;i++) {
			dp[i][i] = 1;
		}
		//状态转移 
		for (int i = n - 2;i &gt;= 0;i--) {
			for (int j = i + 1;j &lt; n;j++) {
				dp[i][j] = n;
				if (check(a[i],a[j]) == true) {
					dp[i][j] = min(dp[i][j],dp[i + 1][j - 1]); 
					go[i][j] = -1;
				}
				for (int x = i;x &lt; j;x++) {
					if (dp[i][j] &gt; (dp[i][x] + dp[x + 1][j])) {
						dp[i][j] = dp[i][x] + dp[x + 1][j];
						go[i][j] = x;
					}
				}
			}
		}
		//输出 
		out_put(0,n - 1);
		printf(&quot;\n&quot;);
        if (t) {
			printf(&quot;\n&quot;);
		}
	}
	return 0;
}

</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>h</mi><mi>e</mi><mtext> </mtext><mi>e</mi><mi>n</mi><mi>d</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">The\ end.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mspace"> </span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord">.</span></span></span></span></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [Codeforces 2B]The least round way]]></title>
        <id>https://norman6666.github.io/post/ti-jie-codeforces-2bthe-least-round-way/</id>
        <link href="https://norman6666.github.io/post/ti-jie-codeforces-2bthe-least-round-way/">
        </link>
        <updated>2021-04-03T12:42:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题解-codeforces-2bthe-least-round-way">题解 [Codeforces 2B]The least round way</h2>
<h3 id="方法动态规划">方法：动态规划</h3>
<p>这题我们可以用动态规划解决。</p>
<p>既然让我们走过的路程的乘积的后缀 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 最小，产生后缀 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 方法共有：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>∗</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">2 * 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>，即产生的后缀 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 个数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>c</mi><mi>n</mi><msub><mi>t</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>c</mi><mi>n</mi><msub><mi>t</mi><mn>5</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">min(cnt_2,cnt_5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，即产生的后缀 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 只有一个。</li>
</ul>
<p>我们用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">dp_{i,j,0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 表示到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i,j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 位置最少 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 因子的个数， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">dp_{i,j,1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 表示到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i,j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 位置最少 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 因子的个数。</p>
<p>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>c</mi><mi>n</mi><msub><mi>t</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>c</mi><mi>n</mi><msub><mi>t</mi><mn>5</mn></msub><mo>)</mo><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">min(cnt_2,cnt_5) &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，且有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，那我们直接走 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的路即可，因为此时后缀 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的个数最小一定是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p>
<p>其他就老老实实走最小的路就行了。</p>
<p>注意，当没 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的时候 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>c</mi><mi>n</mi><msub><mi>t</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>c</mi><mi>n</mi><msub><mi>t</mi><mn>5</mn></msub><mo>)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">min(cnt_2,cnt_5) = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，答案为一。</p>
<p>具体见代码。</p>
<h2 id="code">Code:</h2>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
//考虑unsigned long long
typedef long long ll;
inline int read(){
	int z=0,x=1;char c=getchar();
	while(c&gt;'9'||c&lt;'0'){if(c=='-') x=-x; c=getchar();}
	while(c&gt;='0'&amp;&amp;c&lt;='9') z=z*10+c-'0',c=getchar();
	return z*x;
}
inline void write(ll x){
    if(x&lt;0) putchar('-'),x=-x;
    if(x&gt;9) write(x/10);
    putchar(x%10+'0');
}

const int INF = 100000000;
const int N = 1010;
int a[N][N];
int b[N][N][2]; 
int dp[N][N][2];
int main () {
	int n = read();
	int c = -1;
	for (int i = 1;i &lt;= n;i++) {
		for (int j = 1;j &lt;= n;j++) {
			a[i][j] = read();
			int op = a[i][j];
			//记录零的位置和标记非法位置 
			if (op == 0) {
				c = i;
				b[i][j][0] = b[i][j][1] = INF;
				continue;
			} 
			//记录 2 因子个数 
			while (op % 2 == 0) {
				op /= 2;
				b[i][j][0]++;
			}
			//记录 5 因子个数 
			op = a[i][j];
			while (op % 5 == 0) {
				op /= 5;
				b[i][j][1]++;
			}
		}
	} 
	//边界初始化 
	for (int i = 1;i &lt;= n;i++) {
		dp[i][0][0] = dp[i][0][1] = dp[0][i][0] = dp[0][i][1] = INF;
	}
	//dp初始化话 
	dp[1][1][0] = b[1][1][0],dp[1][1][1] = b[1][1][1];
	for(int i = 1;i &lt;= n;i++) {
		for (int j = 1;j &lt;= n;j++) {
			if (i == 1 &amp;&amp; j == 1) {
				continue;
			} 
			//比较 2 因子的个数，记得加上此地方 2 因子的个数 
			if (dp[i - 1][j][0] &lt; dp[i][j - 1][0]) {
				dp[i][j][0] = dp[i - 1][j][0] + b[i][j][0]; 
			} else {
				dp[i][j][0] = dp[i][j - 1][0] + b[i][j][0];
			}
			//比较 5 因子的个数，记得加上此地方 5 因子的个数 
			if (dp[i - 1][j][1] &lt; dp[i][j - 1][1]) {
				dp[i][j][1] = dp[i - 1][j][1] + b[i][j][1]; 
			} else {
				dp[i][j][1] = dp[i][j - 1][1] + b[i][j][1];
			}
		}
	} 
	string ans;
	int k = -1;
	//k 记录那个更小 
	if (dp[n][n][0] &lt; dp[n][n][1]) {
		k = 0;
	} else {
		k = 1;
	}
	//能直接走零 
	if (c != -1 &amp;&amp; dp[n][n][k] &gt; 0) {
		puts(&quot;1&quot;);
		for (int i = 1;i &lt; c;i++) {
			printf(&quot;D&quot;);
		}
		for (int i = 1;i &lt; n;i++) {
			printf(&quot;R&quot;);
		}
		for (int i = c;i &lt; n;i++) {
			printf(&quot;D&quot;);
		}
		return 0;
	}
	int x = n,y = n;
	while (true) { 
		//哪边小往哪边走 
		if (dp[x - 1][y][k] &lt; dp[x][y - 1][k]) {
			x--;
			ans += 'D';
		} else {
			y--;
			ans += 'R';
		}
	 	if (x == 1) {
			for (int i = 1;i &lt; y;i++) {
				ans += 'R';
			}
			break;
		}
		if (y == 1) {
			for (int i = 1;i &lt; x;i++) {
				ans += 'D';
			}
			break;
		}	
	}
	//特判 
	if (c == -1 &amp;&amp; dp[n][n][k] == 0) {
		printf(&quot;0\n&quot;);
	} else {
		printf(&quot;%d\n&quot;,dp[n][n][k]);
	}
	//倒序输出 
	for (int i = ans.length() - 1;i &gt;= 0;i--) {
		printf(&quot;%c&quot;,ans[i]);
	}
	return 0;
}

</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>h</mi><mi>e</mi><mtext> </mtext><mi>e</mi><mi>n</mi><mi>d</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">The\ end.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mspace"> </span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord">.</span></span></span></span></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [POJ 1742]Coins]]></title>
        <id>https://norman6666.github.io/post/ti-jie-poj-1742coins/</id>
        <link href="https://norman6666.github.io/post/ti-jie-poj-1742coins/">
        </link>
        <updated>2021-04-03T12:41:46.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题解-poj-1742coins">题解 [POJ 1742]Coins</h2>
<h3 id="方法动态规划背包">方法：动态规划+背包</h3>
<p>这题我们可以用动态规划+背包解决。</p>
<p>如果一个物体的体积 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∗</mo></mrow><annotation encoding="application/x-tex">*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">∗</span></span></span></span> 个数超过总体积的话，那么我们可以用完全背包来做，因为此时我们可以把物体当成无限个来处理。</p>
<p>否则的话我们就老老实实用多重背包。</p>
<p>由于第 i<em>i</em>种物品都是一样的，我们考虑把物品打包出售。即用由 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">\log_2 n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>的整数倍通过加法表示一个数，如： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>21</mn><mo>=</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>4</mn><mo>+</mo><mn>8</mn><mo>+</mo><mn>6</mn><mo separator="true">,</mo><mn>36</mn><mo>=</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>4</mn><mo>+</mo><mn>8</mn><mo>+</mo><mn>16</mn><mo>+</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">21=1+2+4+8+6,36=1+2+4+8+16+5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span></p>
<p>在题目中就是让 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>4</mn><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mo>(</mo><mi>c</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>−</mo><msup><mn>2</mn><mi>k</mi></msup><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">c[i]=1+2+4+...+2^{k-1}+(c[i]-2^k+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9324379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>.</p>
<p>因为我们可以用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>0</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>1</mn></msup><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^0,2^1......2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.043548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>，表示出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{k+1} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的所有数，最后再用一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>+</mo><mn>1</mn><mo>−</mo><msup><mn>2</mn><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">m + 1 - 2^{k+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 就能表示出全部的数啦！</p>
<p>时间复杂度就多了一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">log</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span>。</p>
<p>具体见代码。</p>
<h2 id="code">Code:</h2>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
//娉ㄦ剰unsigned long long
typedef long long ll;
inline int read(){
	int z=0,x=1;char c=getchar();
	while(c&gt;'9'||c&lt;'0'){if(c=='-') x=-x; c=getchar();}
	while(c&gt;='0'&amp;&amp;c&lt;='9') z=z*10+c-'0',c=getchar();
	return z*x;
}
inline void write(ll x){
  if(x&lt;0) putchar('-'),x=-x;
  if(x&gt;9) write(x/10);
  putchar(x%10+'0');
}

const int N = 110;
int a[N],c[N];
const int M = 100010;
int dp[M];
int n,m;

void lyback(int v) {
    //01背包
	for (int i = m;i &gt;= v;i--) {
		dp[i] |= dp[i - v];
	}
}

void wqback(int v) {
    //完全背包
	for (int i = v;i &lt;= m;i++) {
		dp[i] |= dp[i - v];
	}
}

int main () {
	n = read(),m = read();
	for (int i = 1;i &lt;= n;i++) {
		a[i] = read();
	} 
	for (int i = 1;i &lt;= n;i++) {
		c[i] = read();
	}
	dp[0] = 1;
	for (int i = 1;i &lt;= n;i++) {
		if (c[i] != 0) {
            //可以无限选的
			if (c[i] * a[i] &gt;= m) {
				wqback(a[i]);
			} else {
				int j = 1;
                //对2的一次方到2的k次方处理
				while (j &lt; c[i]) {
					lyback(a[i] * j);
					c[i] -= j;
					j &lt;&lt;= 1;
				}
                //对m + 1 - 2的k+1次方处理
				if (c[i] &gt; 0) {
					lyback(a[i] * c[i]);
				}
			}
		}
	}
    //统计能凑成的个数
	int ans = 0;
	for (int i = 1;i &lt;= m;i++) {
		ans += dp[i];
	}
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}

</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>h</mi><mi>e</mi><mtext> </mtext><mi>e</mi><mi>n</mi><mi>d</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">The\ end.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mspace"> </span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord">.</span></span></span></span></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python爬虫图-动漫]]></title>
        <id>https://norman6666.github.io/post/test/</id>
        <link href="https://norman6666.github.io/post/test/">
        </link>
        <updated>2021-03-14T04:46:03.000Z</updated>
        <content type="html"><![CDATA[<p>看人品吧</p>
<figure data-type="image" tabindex="1"><img src="https://uploadbeta.com/api/pictures/random/?key=BingEverydayWallpaperPicture" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="http://www.dmoe.cc/random.php" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://api.ixiaowai.cn/api/api.php" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://acg.toubiec.cn/acgurl" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://acg.toubiec.cn/random.php" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://img.paulzzh.tech/touhou/random" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://img.xjh.me/random_img.php?return=302" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://acg.toubiec.cn/random" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://s0.xinger.ink/acgimg/acgurl.php" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="10"><img src="http://acg.nmkjwl.cn/random.php" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="11"><img src="http://img.xjh.me/random_img.php?typ&amp;return=302" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="http://img.xjh.me/random_img.php?typ&amp;ctyp&amp;return=302" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="13"><img src="http://img.xjh.me/random_img.php?type=bg&amp;ctyp&amp;return=302" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="http://img.xjh.me/random_img.php?type=bg&amp;ctype=acg&amp;return=302" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="15"><img src="http://img.xjh.me/random_img.php?type=bg&amp;return=302" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="16"><img src="https://acg.toubiec.cn/random.php?" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="17"><img src="http://img.xjh.me/random_img.php?tctype=acg&amp;return=302" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="18"><img src="http://api.mtyqx.cn/tapi/random.php" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="19"><img src="http://api.mtyqx.cn/api/random.php" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="20"><img src="https://acg.yanwz.cn/wallpaper/api.php" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="21"><img src="https://acg.yanwz.cn/api.php" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="22"><img src="https://www.xiaobaibk.com/api/acg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="23"><img src="https://img.paulzzh.tech/touhou/random?proxy=1" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="24"><img src="http://pic.tsmp4.net/api/erciyuan/img.php" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="25"><img src="https://random.52ecy.cn/randbg.php" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="26"><img src="http://web.zcjun.com/background/random_img" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="27"><img src="http://host.oierlin.cf/img/bg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="28"><img src="http://host.oierlin.cf/img" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="29"><img src="https://img.mdashen.com/img1.php" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="30"><img src="https://img.mdashen.com/img0.php" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="31"><img src="http://show.gandyli.xyz" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="32"><img src="https://api.paugram.com/wallpaper/" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="33"><img src="https://acg.lyiqk.cn/acg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="34"><img src="https://acg.lyiqk.cn/dfproject" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="35"><img src="https://acg.lyiqk.cn/miku" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="36"><img src="https://api.17uw.cn/api/bg/sinaimg.php" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="37"><img src="http://api.3ewl.cc/acg/img.php" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [POJ 2456]Aggressive cows]]></title>
        <id>https://norman6666.github.io/post/ti-jie-poj-2456aggressive-cows/</id>
        <link href="https://norman6666.github.io/post/ti-jie-poj-2456aggressive-cows/">
        </link>
        <updated>2021-02-18T12:18:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题解-poj-2456aggressive-cows">题解 [POJ 2456]Aggressive cows</h2>
<h3 id="方法二分贪心">方法：二分+贪心</h3>
<p>这题我们可以用二分和贪心解决。</p>
<p>我们二分相邻距离的最小值，用这个值带进去贪心，第一个牛栏必选，之后如果某两个的牛栏大于现在的值就选，当任意时刻能放的牛大于要求的牛就 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">break</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 且返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">true</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span></span></span></span>，否则不满就返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">false</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span></span></span></span>。</p>
<p>贪心的实现：</p>
<pre><code class="language-cpp">bool get (int mid) {
    //计数器cnt,j代表上次选的牛栏
	int cnt = 1;
	int j = 1;
    //最小的牛栏必选
	for (int i = 2;i &lt;= n;i++) {
        //两个之间的区间满足条件
		if (a[i] - a[j] &gt;= mid) {
			cnt++,j = i;
		}
		if (cnt &gt;= m) {
			return true;
		}
	}
	return false;
}
</code></pre>
<p>具体见代码。</p>
<p><a href="https://vjudge.net/solution/29669838">AC记录</a></p>
<h2 id="code">Code:</h2>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
//考虑unsigned long long
typedef long long ll;
inline int read(){
	int z=0,x=1;char c=getchar();
	while(c&gt;'9'||c&lt;'0'){if(c=='-') x=-x; c=getchar();}
	while(c&gt;='0'&amp;&amp;c&lt;='9') z=z*10+c-'0',c=getchar();
	return z*x;
}
inline void write(ll x){
    if(x&lt;0) putchar('-'),x=-x;
    if(x&gt;9) write(x/10);
    putchar(x%10+'0');
}

const int N = 100010;
int a[N];
int n,m;

bool get (int mid) {
    //计数器cnt,j代表上次选的牛栏
	int cnt = 1;
	int j = 1;
    //最小的牛栏必选
	for (int i = 2;i &lt;= n;i++) {
        //两个之间的区间满足条件
		if (a[i] - a[j] &gt;= mid) {
			cnt++,j = i;
		}
		if (cnt &gt;= m) {
			return true;
		}
	}
	return false;
}

int main () {
	n = read(),m = read();
	for (int i = 1;i &lt;= n;i++) {
		a[i] = read();
	}
	sort(a+1,a+1+n);
	//左端点为0,右端点为牛栏间的最大距离，best保存答案 
	int l = 0,r = a[n] - a[1],best = -1;
	while(l &lt;= r) {
		int mid = (l + r) / 2;
		//满足条件 
		if (get(mid) == true) {
			l = mid + 1;
			best = mid;
		} else {
			r = mid - 1;
		}
	}
	printf(&quot;%d\n&quot;,best);
	return 0;
}

</code></pre>
<h3 id="我的错误">我的错误：</h3>
<ul>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>o</mi><mi>r</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">sort</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span></span></span></span> 函数写在了定义左端点和右端点的后面，导致程序错误。</p>
</li>
<li>
<p>最小的距离可以是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</p>
</li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>h</mi><mi>e</mi><mtext> </mtext><mi>e</mi><mi>n</mi><mi>d</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">The\ end.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mspace"> </span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord">.</span></span></span></span></p>
]]></content>
    </entry>
</feed>